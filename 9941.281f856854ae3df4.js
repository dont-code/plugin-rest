(self.webpackChunkrest_tester=self.webpackChunkrest_tester||[]).push([[9941],{9941:(R,m,n)=>{n.r(m),n.d(m,{RestModule:()=>i,RestStoreProvider:()=>y,SourceHandler:()=>s});var P=n(7863),t=n(7138);class M{getConfiguration(){return{plugin:{id:"RestPlugin","display-name":"A plugin for entities managed through Rest APIs .",version:"1.0.0"},"schema-updates":[{id:"rest-source",description:"Add rest type of source",changes:[{location:{parent:"#/$defs/source",id:"type"},update:{enum:["Rest"]},props:{url:{type:"string"}},replace:!1}]}],"global-handlers":[{location:{parent:t.DontCodeModel.ROOT+"/sources",id:"type",values:["Rest"]},class:{name:"SourceHandler",source:"rest"}}]}}pluginInit(e){}}var v=n(7401),S=n(6602),h=n(2256),p=n(2369);class y extends t.AbstractDontCodeStoreProvider{constructor(e){super(),this.http=e,this.modelMgr=t.dtcde.getModelManager()}deleteEntity(e,d){return Promise.resolve(!1)}loadEntity(e,d){const u=this.modelMgr.findAtPosition(e,!1);if(null===u)return Promise.reject("No entity found at position "+e);const l=this.modelMgr.findTargetOfProperty(t.DontCodeModel.APP_ENTITIES_FROM_NODE,e)?.value;let g=l.url;if(null!=d)try{const r=new URL(l.url);r.pathname=r.pathname+"/"+d,g=r.toString()}catch{return console.error("The url for loading the entity is incorrect",l.url),Promise.reject("The url for loading the entity is incorrect:"+l.url)}const o=this.http.get(g,{observe:"body",responseType:"json"}).pipe((0,p.map)(r=>{if(Array.isArray(r))throw new Error("When loading an entity, the returned value should be one element");return r}),(0,p.map)(r=>(t.StoreProviderHelper.cleanUpLoadedData([r],t.StoreProviderHelper.findSpecialFields(e,u)),r)));return(0,h.lastValueFrom)(o)}searchEntities(e,...d){const u=this.modelMgr.findAtPosition(e,!1);if(null===u)return(0,h.throwError)(()=>new Error("No entity found at position "+e));const l=t.StoreProviderHelper.findSpecialFields(e,u),g=this.modelMgr.findTargetOfProperty(t.DontCodeModel.APP_ENTITIES_FROM_NODE,e)?.value;return this.http.get(g.url,{observe:"body",responseType:"json"}).pipe((0,p.map)(o=>{let r=[];if(Array.isArray(o))r=o;else{let f;for(f in o)Array.isArray(o[f])&&(r=o[f])}return this.applyFilters(r,...d)}),(0,p.map)(o=>(t.StoreProviderHelper.cleanUpLoadedData(o,l),o)))}storeEntity(e,d){return Promise.resolve(void 0)}canStoreDocument(e){return!1}storeDocuments(e,d){return(0,h.throwError)(()=>new Error("Document storage is unsupported."))}}var a=n(549);class s extends v.AbstractPluginHandler{constructor(e){super(),this.httpClient=e,this.storeMgr=t.dtcde.getStoreManager(),this.modelMgr=t.dtcde.getModelManager(),this.storeMgr.setProviderForSourceType(new y(this.httpClient),"Rest")}handleChange(e){t.StoreProviderHelper.clearConfigCache()}}s.\u0275fac=function(e){return new(e||s)(a.\u0275\u0275inject(S.HttpClient))},s.\u0275prov=a.\u0275\u0275defineInjectable({token:s,factory:s.\u0275fac,providedIn:"root"});class i{constructor(){console.log("Rest Plugin registering"),t.dtcde.registerPlugin(new M)}exposedPreviewHandlers(){return new Map([["SourceHandler",s]])}}i.\u0275fac=function(e){return new(e||i)},i.\u0275mod=a.\u0275\u0275defineNgModule({type:i,id:"dontcode-plugin/rest"}),i.\u0275inj=a.\u0275\u0275defineInjector({imports:[P.CommonModule]}),a.\u0275\u0275registerNgModuleType(i,"dontcode-plugin/rest")}}]);