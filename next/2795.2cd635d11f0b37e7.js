(self.webpackChunkrest_tester=self.webpackChunkrest_tester||[]).push([[2795],{2795:(j,h,i)=>{i.r(h),i.d(h,{RestModule:()=>y,RestStoreProvider:()=>f,SourceHandler:()=>m});var P=i(1395),t=i(9732);class M{getConfiguration(){return{plugin:{id:"RestPlugin","display-name":"A plugin for entities managed through Rest APIs .",version:"1.0.0"},"schema-updates":[{id:"rest-source",description:"Add rest type of source",changes:[{location:{parent:"#/$defs/source",id:"type"},update:{enum:["Rest"]},props:{url:{type:"string"}},replace:!1}]}],"global-handlers":[{location:{parent:t.DontCodeModel.ROOT+"/sources",id:"type",values:["Rest"]},class:{name:"SourceHandler",source:"rest"}}]}}pluginInit(e){}}var v=i(8584),S=i(2123),p=i(6241),c=i(4346);class f extends t.AbstractDontCodeStoreProvider{constructor(e){super(),this.http=e,this.modelMgr=t.dtcde.getModelManager()}deleteEntity(e,n){return Promise.resolve(!1)}loadEntity(e,n){const l=this.modelMgr.findAtPosition(e,!1);if(null===l)return Promise.reject("No entity found at position "+e);const d=this.modelMgr.findTargetOfProperty(t.DontCodeModel.APP_ENTITIES_FROM_NODE,e)?.value;let u=d.url;if(null!=n)try{const r=new URL(d.url);r.pathname=r.pathname+"/"+n,u=r.toString()}catch{return console.error("The url for loading the entity is incorrect",d.url),Promise.reject("The url for loading the entity is incorrect:"+d.url)}const s=this.http.get(u,{observe:"body",responseType:"json"}).pipe((0,c.map)(r=>{if(Array.isArray(r))throw new Error("When loading an entity, the returned value should be one element");return r}),(0,c.map)(r=>(t.StoreProviderHelper.cleanUpLoadedData([r],t.StoreProviderHelper.findSpecialFields(e,l)),r)));return(0,p.lastValueFrom)(s)}searchEntities(e,...n){const l=this.modelMgr.findAtPosition(e,!1);if(null===l)return(0,p.throwError)(()=>new Error("No entity found at position "+e));const d=t.StoreProviderHelper.findSpecialFields(e,l),u=this.modelMgr.findTargetOfProperty(t.DontCodeModel.APP_ENTITIES_FROM_NODE,e)?.value;return this.http.get(u.url,{observe:"body",responseType:"json"}).pipe((0,c.map)(s=>{let r=[];if(Array.isArray(s))r=s;else{let g;for(g in s)Array.isArray(s[g])&&(r=s[g])}return t.StoreProviderHelper.applyFilters(r,...n)}),(0,c.map)(s=>(t.StoreProviderHelper.cleanUpLoadedData(s,d),s)))}storeEntity(e,n){return Promise.reject("RestStoreProvider cannot store elements")}canStoreDocument(e){return!1}storeDocuments(e,n){return(0,p.throwError)(()=>new Error("Document storage is unsupported."))}}var a=i(1855);let m=(()=>{class o extends v.AbstractPluginHandler{constructor(n){super(),this.httpClient=n,this.storeMgr=t.dtcde.getStoreManager(),this.modelMgr=t.dtcde.getModelManager(),this.storeMgr.setProviderForSourceType(new f(this.httpClient),"Rest")}handleChange(n){t.StoreProviderHelper.clearConfigCache()}static#e=this.\u0275fac=function(l){return new(l||o)(a.\u0275\u0275inject(S.HttpClient))};static#t=this.\u0275prov=a.\u0275\u0275defineInjectable({token:o,factory:o.\u0275fac,providedIn:"root"})}return o})(),y=(()=>{class o{constructor(){console.log("Rest Plugin registering"),t.dtcde.registerPlugin(new M)}exposedPreviewHandlers(){return new Map([["SourceHandler",m]])}static#e=this.\u0275fac=function(l){return new(l||o)};static#t=this.\u0275mod=a.\u0275\u0275defineNgModule({type:o,id:"dontcode-plugin/rest"});static#r=this.\u0275inj=a.\u0275\u0275defineInjector({imports:[P.CommonModule]})}return o})();a.\u0275\u0275registerNgModuleType(y,"dontcode-plugin/rest")}}]);